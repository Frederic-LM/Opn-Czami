# Copyright (C) 2025 Fr√©d√©ric Levi Mazloum
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see
# <https://www.gnu.org/licenses/>.

# --- Legato key reader - PROOF OF CONCEPT --- for Op'n Czami V3 !!! non compatible with previous versions !!!
# This application serves as a secure verifier for Legato Key generated by the
# Op'n-Cezami app. Its primary purpose is to confirm the authenticity
# and integrity of a digital document without needing a central authority. It
# achieves this through a decentralized, public-key cryptography workflow.
#


import tkinter as tk
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from ttkbootstrap.scrolled import ScrolledText
from tkinter import filedialog, messagebox
import json, base64, io, re, requests, os, threading, textwrap, hashlib, zlib, cbor2, base45
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import ed25519
from PIL import Image, ImageTk, ImageDraw, ImageFont
from pyzbar import pyzbar

ISSUER_DB_FILE = "legatokeyreader.json"

class VerifierApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Czami - Secure Verifier Tool v5 (Fixed)")
        self.root.geometry("800x1100")

        self.issuers = {}
        self.logo_placeholder = ImageTk.PhotoImage(Image.new("RGB", (80, 80), "#E0E0E0"))
        self.doc_image_placeholder = self.create_text_image((750, 750), "Load a Legato Key to begin verification...")

        self.load_issuers()

        self.notebook = ttk.Notebook(root, bootstyle="primary")
        self.notebook.pack(pady=10, padx=10, expand=True, fill="both")
        
        self.verifier_frame = ttk.Frame(self.notebook, padding=10)
        self.debug_frame = ttk.Frame(self.notebook, padding=10)
        self.issuer_frame = ttk.Frame(self.notebook, padding=10)
        
        self.notebook.add(self.verifier_frame, text='üîç Verify Document')
        self.notebook.add(self.debug_frame, text='üêû Debug Terminal')
        self.notebook.add(self.issuer_frame, text='üìö Known Issuers')
        
        self.create_verifier_tab()
        self.create_debug_tab()
        self.create_issuer_tab()
        
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

    def create_text_image(self, size, text, color="#F0F0F0", text_color="dimgray"):
        img = Image.new("RGB", size, color)
        draw = ImageDraw.Draw(img)
        try:
            font = ImageFont.truetype("seguisb.ttf", 22)
        except IOError:
            font = ImageFont.load_default()
        
        wrapped_text = textwrap.wrap(text, width=55)
        total_text_height = sum([font.getbbox(line)[3] for line in wrapped_text]) + (len(wrapped_text) - 1) * 5
        current_y = (size[1] - total_text_height) / 2
        
        for line in wrapped_text:
            line_bbox = font.getbbox(line)
            line_width = line_bbox[2] - line_bbox[0]
            position = ((size[0] - line_width) / 2, current_y)
            draw.text(position, line, fill=text_color, font=font)
            current_y += font.getbbox(line)[3] + 5

        return ImageTk.PhotoImage(img)

    def on_closing(self):
        self.save_issuers()
        self.root.destroy()
    
    def load_issuers(self):
        try:
            if os.path.exists(ISSUER_DB_FILE):
                with open(ISSUER_DB_FILE, 'r') as f:
                    self.issuers = json.load(f)
            else:
                self.issuers = {}
        except Exception as e:
            messagebox.showerror("DB Error", f"Could not load issuer database: {e}")

    def save_issuers(self):
        try:
            with open(ISSUER_DB_FILE, 'w') as f:
                json.dump(self.issuers, f, indent=4)
        except Exception as e:
            messagebox.showerror("DB Error", f"Could not save issuer database: {e}")

    def create_verifier_tab(self):
        frame = self.verifier_frame
        
        ttk.Button(frame, text="Load QR Image...", command=self.scan_and_process_qr, bootstyle="primary").pack(fill='x', pady=5, ipady=8)

        results_frame = ttk.Labelframe(frame, text="Verification Result", padding=15, bootstyle="info")
        results_frame.pack(fill="both", expand=True, pady=10)

        top_container = ttk.Frame(results_frame)
        top_container.pack(fill="x", pady=(0, 10))
        logo_status_frame = ttk.Frame(top_container)
        logo_status_frame.pack(side="left", padx=(0, 20), anchor="nw")
        self.logo_label = ttk.Label(logo_status_frame, image=self.logo_placeholder)
        self.logo_label.pack()

        message_frame = ttk.Frame(top_container)
        message_frame.pack(side="left", expand=True, fill="x", anchor="nw")
        self.issuer_label = ttk.Label(message_frame, text="Issuer: N/A", font=("Segoe UI", 11, "bold"))
        self.issuer_label.pack(anchor="w")
        
        style = ttk.Style()
        theme_bg_color = style.colors.get("bg")
        theme_fg_color = style.colors.get("fg")
        self.decoded_message_text = tk.Text(
            message_frame, height=5, wrap="word", font=("Segoe UI", 10),
            bd=0, relief='flat', background=theme_bg_color, foreground=theme_fg_color, state="disabled"
        )
        self.decoded_message_text.pack(fill="x", expand=True, pady=(2,0))
        self.decoded_message_text.tag_configure("bold", font=("Segoe UI", 10, "bold"))
        self.decoded_message_text.tag_configure("green", foreground=style.colors.get("success"), font=("Segoe UI", 10, "bold"))

        self.doc_image_label = ttk.Label(results_frame, image=self.doc_image_placeholder)
        self.doc_image_label.pack(fill="both", expand=True, pady=5)
        
        log_frame = ttk.Labelframe(results_frame, text="Verification Log", padding=5, bootstyle="secondary")
        log_frame.pack(fill='x', side='bottom', pady=(10,0))
        
        log_bg_color = style.colors.get('light')
        self.log_text = ScrolledText(
            log_frame, height=8, wrap="word", font=('Consolas', 9), autohide=True,
            bd=0, relief='flat', bg=log_bg_color
        )
        self.log_text.pack(fill='x', expand=True)
        self.log_text.text.config(state="disabled") # CORRECTED
        self.log_text.tag_configure("success", foreground=style.colors.get("success"))
        self.log_text.tag_configure("failure", foreground=style.colors.get("danger"))
        self.log_text.tag_configure("info", foreground=style.colors.get("secondary"))
        self.log_text.tag_configure("warning", foreground=style.colors.get("warning"))

        self.reset_decoder_view()

    def create_debug_tab(self):
        ttk.Label(self.debug_frame, text="Raw QR Data & Decoding Process", font="-weight bold").pack(anchor="w")
        self.debug_text = ScrolledText(self.debug_frame, wrap="word", font=('Consolas', 10), autohide=True, padding=5)
        self.debug_text.pack(fill="both", expand=True, pady=5)
        self.debug_text.text.config(state="disabled") # CORRECTED
        self.debug_text.tag_configure("label", font=('Consolas', 10, 'bold'), foreground="#0d6efd")
        self.debug_text.tag_configure("data", foreground="#343a40")
        self.debug_text.tag_configure("error", foreground="#dc3545")
        self.debug_text.tag_configure("success", foreground="#198754")
        
    def create_issuer_tab(self):
        frame = self.issuer_frame
        cols = ('ID', 'Name', 'Info URL')
        self.issuer_tree = ttk.Treeview(frame, columns=cols, show='headings', bootstyle="primary")
        self.issuer_tree.pack(fill="both", expand=True)
        for col in cols:
            self.issuer_tree.heading(col, text=col)
        self.issuer_tree.column("ID", width=200, stretch=False)
        self.issuer_tree.column("Name", width=250)
        
        btn_frame = ttk.Frame(frame)
        btn_frame.pack(fill='x', pady=(10, 0))
        ttk.Button(btn_frame, text="Forget Selected Issuer", command=self.delete_selected_issuer, bootstyle="outline-danger").pack(side="left", expand=True, fill='x', padx=2)
        ttk.Button(btn_frame, text="Refresh List", command=self.refresh_issuer_list, bootstyle="outline-secondary").pack(side="left", expand=True, fill='x', padx=2)
        self.refresh_issuer_list()
        
    def reset_decoder_view(self):
        self.issuer_label.config(text="Issuer: N/A")
        self.logo_label.config(image=self.logo_placeholder)
        self.logo_label.image = self.logo_placeholder
        self.decoded_message_text.config(state="normal")
        self.decoded_message_text.delete("1.0", "end")
        self.decoded_message_text.config(state="disabled")
        self.doc_image_placeholder = self.create_text_image((750, 750), "Load a QR code image to begin verification...")
        self.doc_image_label.config(image=self.doc_image_placeholder)
        self.doc_image_label.image = self.doc_image_placeholder
        if hasattr(self, 'log_text'):
            self.log_text.text.config(state="normal") # CORRECTED
            self.log_text.text.delete("1.0", "end")
            self.log_text.text.config(state="disabled")
    
    def log_message(self, message, style="info"):
        self.root.after(0, self._log_message_thread_safe, message, style)

    def _log_message_thread_safe(self, message, style):
        self.log_text.text.config(state="normal") # CORRECTED
        self.log_text.insert("end", f"> {message}\n", style)
        self.log_text.see("end")
        self.log_text.text.config(state="disabled") # CORRECTED

    def debug_log(self, label, data="", style="data"):
        self.root.after(0, self._debug_log_thread_safe, label, data, style)

    def _debug_log_thread_safe(self, label, data, style):
        self.debug_text.text.config(state="normal") # CORRECTED
        self.debug_text.insert("end", f"{label:<25}", "label")
        self.debug_text.insert("end", f": {data}\n", style)
        self.debug_text.see("end")
        self.debug_text.text.config(state="disabled") # CORRECTED

    def scan_and_process_qr(self):
        self.reset_decoder_view()
        self.debug_text.text.config(state="normal") # CORRECTED
        self.debug_text.delete("1.0", "end")
        self.debug_text.text.config(state="disabled") # CORRECTED
        self.debug_log("="*60, "="*60, "label")
        self.debug_log("STARTING NEW SCAN", "")

        path = filedialog.askopenfilename(filetypes=[("Image Files", "*.png *.jpg")]);
        if not path: 
            self.debug_log("User cancelled file selection", "")
            return
        
        self.log_message(f"Scanning image: {os.path.basename(path)}...")
        self.debug_log("File Path", path)
        try:
            decoded_qrs = pyzbar.decode(Image.open(path))
        except Exception as e:
            self.log_message(f"ERROR: Could not open image: {e}", "failure")
            self.debug_log("PYZBAR ERROR", str(e), "error")
            return

        if not decoded_qrs:
            self.log_message("FAILURE: No QR code found.", "failure")
            self.debug_log("PYZBAR RESULT", "No QR codes detected in the image.", "error")
            return

        self.log_message(f"SUCCESS: Found {len(decoded_qrs)} QR code(s).", "success")
        
        raw_bytes = decoded_qrs[0].data
        self.debug_log("RAW BYTES", str(raw_bytes))
        
        try:
            qr_string = raw_bytes.decode('utf-8')
            self.debug_log("DECODED (UTF-8)", qr_string)
        except UnicodeDecodeError:
            self.debug_log("DECODING ERROR", "Could not decode raw bytes as UTF-8.", "error")
            self.log_message("ERROR: QR data is not valid UTF-8.", "failure")
            return
        
        if qr_string.strip().startswith('{'):
            self.log_message("Detected legacy JSON Issuer QR format...")
            self.debug_log("QR Type Detected", "Legacy JSON Issuer")
            try:
                payload = json.loads(qr_string)
                if payload.get("qr_type") == "issuer_info_v1":
                     threading.Thread(target=self.add_issuer_from_data, args=(payload,), daemon=True).start()
                else:
                    raise ValueError("JSON payload is not a valid legacy Issuer QR.")
            except Exception as e:
                self.log_message(f"ERROR: Legacy Issuer QR is malformed: {e}", "failure")
                self.debug_log("JSON PARSE FAILED", str(e), "error")

        elif ':' in qr_string:
            self.log_message("Detected new Document QR format...")
            self.debug_log("QR Type Detected", "New Document QR")
            threading.Thread(target=self.process_verification_qr, args=(qr_string,), daemon=True).start()

        else:
            self.log_message("Detected new compressed Issuer QR format...")
            self.debug_log("QR Type Detected", "New Compressed Issuer")
            threading.Thread(target=self.process_issuer_qr, args=(qr_string,), daemon=True).start()

    def process_verification_qr(self, qr_string):
        try:
            issuer_id, payload_b45 = qr_string.split(':', 1)
            self.debug_log("Step 1: Issuer ID", issuer_id)
            self.debug_log("Step 1: Payload (B45)", payload_b45[:60] + "...")

            issuer_info = self.issuers.get(issuer_id.upper())
            if not issuer_info:
                raise ValueError(f"Issuer '{issuer_id}' is not in the trusted database.")
            self.log_message(f"Issuer '{issuer_info['name']}' found in trusted database.", "success")
            self.debug_log("Step 2: Trust Check", f"OK. Found '{issuer_info['name']}'.", "success")
            self.root.after(0, lambda: self.issuer_label.config(text=f"Issued by: {issuer_info.get('name', 'N/A')}"))
            self.display_issuer_logo(issuer_id.upper())

            combined_bytes = base45.b45decode(payload_b45)
            self.debug_log("Step 3: B45 Decoded", f"{len(combined_bytes)} bytes total")

            signature_bytes = combined_bytes[-64:]
            payload_compressed = combined_bytes[:-64]
            self.debug_log("Step 4: Split Signature", f"{len(signature_bytes)} bytes")
            self.debug_log("Step 4: Split Payload", f"{len(payload_compressed)} bytes (compressed)")
            
            pub_key = serialization.load_pem_public_key(issuer_info['pub_key_pem'].encode('utf-8'))
            pub_key.verify(signature_bytes, payload_compressed)
            self.log_message("SUCCESS: Cryptographic signature is valid.", "success")
            self.debug_log("Step 5: Signature Verify", "OK", "success")

            payload_cbor = zlib.decompress(payload_compressed, wbits=-15)
            self.debug_log("Step 6: Decompressed", f"{len(payload_cbor)} bytes (CBOR)")
            
            decoded_payload = cbor2.loads(payload_cbor)
            pretty_payload = json.dumps({k: (v.hex() if isinstance(v, bytes) else v) for k, v in decoded_payload.items()}, indent=2)
            self.debug_log("Step 7: Decoded CBOR", f"\n{pretty_payload}")

            public_message = decoded_payload.get('m', 'No message provided.')
            doc_num = decoded_payload.get('n')
            self.root.after(0, self.render_formatted_text, public_message, doc_num)

            filename_stem = decoded_payload.get('i')
            expected_hash = decoded_payload.get('h', b'').hex()
            if not filename_stem or not expected_hash:
                raise ValueError("Payload is missing image filename or hash.")
            self.log_message("Payload decoded. Now verifying control image...")
            
            payload_for_fetch = {'imgId': f"{filename_stem}.lky", 'h': expected_hash}
            self.fetch_and_verify_doc_image(issuer_info, payload_for_fetch)

        except Exception as e:
            self.log_message(f"VERIFICATION FAILED: {e}", "failure")
            self.debug_log("PROCESS FAILED", str(e), "error")
            self.root.after(0, self.display_error_on_image_area, f"VERIFICATION FAILED!\n\nThis certificate is NOT authentic.\n\nError: {e}")

    def fetch_and_verify_doc_image(self, issuer_info, payload):
        self.log_message("Fetching control image from issuer's server...")
        base_url = issuer_info.get("image_base_url"); img_id = payload.get("imgId")
        if not base_url or not img_id:
            self.log_message("Image URL or ID missing in QR payload.", "failure")
            self.root.after(0, self.display_error_on_image_area, "Signature is valid, but image URL is missing.")
            return

        full_image_url = os.path.join(base_url, img_id).replace("\\", "/")
        self.log_message(f"Requesting URL: {full_image_url}")
        try:
            response = requests.get(full_image_url, timeout=10); response.raise_for_status()
            lky_file_data = response.content
            self.log_message("SUCCESS: Control LKY file successfully downloaded.", "success")

            self.log_message("Verifying LKY file integrity with checksum...")
            expected_hash = payload.get('h')
            
            calculated_hash = hashlib.sha256(lky_file_data).hexdigest()
            self.log_message(f"   - Expected Hash: {expected_hash}")
            self.log_message(f"   - Calculated Hash: {calculated_hash}")

            if calculated_hash != expected_hash:
                self.log_message("FAILURE: LKY file integrity check FAILED! The file on the server may have been altered.", "failure")
                raise ValueError("LKY file on server does not match original signature.")
            
            self.log_message("SUCCESS: LKY file integrity confirmed. Checksum matches.", "success")
            
            # Now, we must extract the image from the LKY file to display it
            # This is a simplified extraction assuming the manifest is at the end
            manifest_len_bytes = lky_file_data[-4:]
            manifest_len = int.from_bytes(manifest_len_bytes, 'big')
            manifest_start = len(lky_file_data) - 4 - manifest_len
            manifest_json_bytes = lky_file_data[manifest_start:-4]
            manifest = json.loads(manifest_json_bytes)
            image_length = manifest.get('imageLength')

            if not image_length:
                raise ValueError("LKY manifest is corrupt or missing 'imageLength'.")

            image_data = lky_file_data[:image_length]

            pil_img = Image.open(io.BytesIO(image_data)); w, h = pil_img.size
            max_w, max_h = 750, 750
            ratio = min(max_w/w, max_h/h); new_size = (int(w*ratio), int(h*ratio))
            pil_img = pil_img.resize(new_size, Image.Resampling.LANCZOS)
            img_tk = ImageTk.PhotoImage(pil_img)
            self.root.after(0, lambda: [
                self.doc_image_label.config(image=img_tk),
                setattr(self.doc_image_label, 'image', img_tk)
            ])
        except Exception as e:
            self.log_message(f"ERROR: Failed to load or verify image: {e}", "failure")
            self.root.after(0, self.display_error_on_image_area, f"! Warning: This is a valid certificate, but the control image could not be loaded or verified. Error: {e}")

    def display_error_on_image_area(self, message):
        error_img_tk = self.create_text_image((750, 750), message, color="#FFF3CD", text_color="#D9534F")
        self.doc_image_label.config(image=error_img_tk); self.doc_image_label.image = error_img_tk

    def display_issuer_logo(self, issuer_id):
        threading.Thread(target=self._fetch_logo, args=(issuer_id,), daemon=True).start()

    def _fetch_logo(self, issuer_id):
        logo_url = self.issuers.get(issuer_id, {}).get('logo_url')
        if not logo_url: return
        try:
            response = requests.get(logo_url, timeout=5); response.raise_for_status()
            pil_img = Image.open(io.BytesIO(response.content)).resize((80, 80), Image.Resampling.LANCZOS)
            img_tk = ImageTk.PhotoImage(pil_img)
            self.root.after(0, lambda: [self.logo_label.config(image=img_tk), setattr(self.logo_label, 'image', img_tk)])
        except Exception as e: print(f"Failed to load logo from {logo_url}: {e}")

    def render_formatted_text(self, message, doc_num=None):
        self.decoded_message_text.config(state="normal")
        self.decoded_message_text.delete("1.0", "end")
        
        if doc_num:
            self.decoded_message_text.insert("end", "Document #: ", "bold")
            self.decoded_message_text.insert("end", f"{doc_num}\n\n", "green")
        
        self.decoded_message_text.insert("end", message)
        self.decoded_message_text.config(state="disabled")

    def refresh_issuer_list(self):
        if hasattr(self, 'issuer_tree'):
            for i in self.issuer_tree.get_children(): self.issuer_tree.delete(i)
            for issuer_id, data in sorted(self.issuers.items()):
                self.issuer_tree.insert('', 'end', values=(issuer_id, data['name'], data.get('infoUrl', 'N/A')))

    def add_issuer_from_data(self, data):
        try:
            issuer_id = data.get('id')
            name_in_qr = data.get('name') or data.get('issuername')
            info_url = data.get('infoUrl')

            if not all([issuer_id, name_in_qr, info_url]):
                raise ValueError("Issuer QR data is missing required fields.")

            if issuer_id in self.issuers:
                self.log_message(f"Issuer '{name_in_qr}' is already trusted.", "warning")
                messagebox.showwarning("Exists", f"You already trust issuer: {self.issuers[issuer_id]['name']}")
                return
            
            self.log_message(f"Found new issuer '{name_in_qr}'.")
            if not messagebox.askyesno("Confirm Trust", f"Do you want to trust this issuer and fetch their public key from:\n{info_url}?"):
                self.log_message("User declined to trust.", "warning")
                return
                
            self.log_message(f"Fetching public key from {info_url}...")
            response = requests.get(info_url, timeout=10); response.raise_for_status()
            info_json = response.json()
            self.log_message("Public key file downloaded.", "success")
            
            pub_key_pem = info_json.get('publicKeyPem')
            official_name = info_json.get('issuerName', name_in_qr)
            if not pub_key_pem: raise ValueError("Public key file is missing 'publicKeyPem' field.")
            
            self.log_message("Validating public key format...")
            serialization.load_pem_public_key(pub_key_pem.encode('utf-8'))
            self.log_message("SUCCESS: Public key is valid.", "success")
            
            self.issuers[issuer_id] = {
                'name': official_name, 'infoUrl': info_url, 'pub_key_pem': pub_key_pem,
                'logo_url': info_json.get('logoUrl'), 'image_base_url': info_json.get('imageBaseUrl')
            }
            self.save_issuers()
            self.refresh_issuer_list()
            self.log_message(f"Successfully trusted new issuer: {official_name}", "success")
            messagebox.showinfo("Success", f"Successfully learned and trusted issuer: {official_name}")
            
        except Exception as e:
            self.log_message(f"ERROR: Failed to process Issuer Data: {e}", "failure")
            messagebox.showerror("Error", f"Failed to process Issuer Data: {e}")

    def process_issuer_qr(self, qr_string):
        try:
            self.log_message("Decoding Base45 stream for Issuer QR...")
            compressed_data = base45.b45decode(qr_string)
            self.log_message("Decompressing zlib data...")
            json_string = zlib.decompress(compressed_data).decode('utf-8')
            data = json.loads(json_string)
            self.log_message("SUCCESS: Decoded Issuer QR payload.", "success")
            
            self.add_issuer_from_data(data)
            
        except Exception as e:
            self.log_message(f"ERROR: Failed to process compressed Issuer QR: {e}", "failure")
            messagebox.showerror("Error", f"Failed to process compressed Issuer QR: {e}")

    def delete_selected_issuer(self):
        selected_item = self.issuer_tree.focus()
        if not selected_item:
            messagebox.showwarning("Selection Required", "Please select an issuer to forget.")
            return
        
        issuer_id, issuer_name = self.issuer_tree.item(selected_item)['values'][:2]
        
        if messagebox.askyesno("Confirm Deletion", f"Are you sure you want to forget and no longer trust '{issuer_name}'?"):
            if issuer_id in self.issuers:
                del self.issuers[issuer_id]
                self.save_issuers()
                self.refresh_issuer_list()

if __name__ == "__main__":
    root = ttk.Window(themename="litera")
    app = VerifierApp(root)
    root.mainloop()
