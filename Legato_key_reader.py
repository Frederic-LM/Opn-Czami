# Copyright (C) 2025 Fr√©d√©ric Levi Mazloum
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see
# <https://www.gnu.org/licenses/>.
#
# --- DESCRIPTION ---
# --- Legato key reader - PROOF OF CONCEPT ---
# This application serves as a secure verifier for Legato Key generated by the
# Op'n-Cezami app. Its primary purpose is to confirm the authenticity
# and integrity of a digital document without needing a central authority. It
# achieves this through a decentralized, public-key cryptography workflow.
#

import tkinter as tk
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tkinter import filedialog, messagebox
import json, base64, io, re, requests, os, threading, textwrap, hashlib
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import padding, utils
from PIL import Image, ImageTk, ImageDraw, ImageFont
from pyzbar import pyzbar

ISSUER_DB_FILE = "legatokeyreader.json"

class VerifierApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Czami - Secure Verifier Tool v3.1")
        self.root.geometry("800x1100")

        self.issuers = {}
        self.logo_placeholder = ImageTk.PhotoImage(Image.new("RGB", (80, 80), "#E0E0E0"))
        self.doc_image_placeholder = self.create_text_image((750, 750), "Load a Legato Key to begin verification...")

        self.load_issuers()

        self.notebook = ttk.Notebook(root, bootstyle="primary")
        self.notebook.pack(pady=10, padx=10, expand=True, fill="both")
        
        self.verifier_frame = ttk.Frame(self.notebook, padding=10)
        self.issuer_frame = ttk.Frame(self.notebook, padding=10)
        
        self.notebook.add(self.verifier_frame, text='üîç Verify Document')
        self.notebook.add(self.issuer_frame, text='üìö Known Issuers')
        
        self.create_verifier_tab()
        self.create_issuer_tab()
        
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

    def create_text_image(self, size, text, color="#F0F0F0", text_color="dimgray"):
        img = Image.new("RGB", size, color)
        draw = ImageDraw.Draw(img)
        try: font = ImageFont.truetype("seguisb.ttf", 22)
        except IOError: font = ImageFont.load_default()
        
        wrapped_text = textwrap.wrap(text, width=55)
        total_text_height = sum([font.getbbox(line)[3] for line in wrapped_text]) + (len(wrapped_text) - 1) * 5
        current_y = (size[1] - total_text_height) / 2
        
        for line in wrapped_text:
            line_bbox = font.getbbox(line)
            line_width = line_bbox[2] - line_bbox[0]
            position = ((size[0] - line_width) / 2, current_y)
            draw.text(position, line, fill=text_color, font=font)
            current_y += font.getbbox(line)[3] + 5

        return ImageTk.PhotoImage(img)

    def on_closing(self): self.save_issuers(); self.root.destroy()
    
    def load_issuers(self):
        try:
            if os.path.exists(ISSUER_DB_FILE):
                with open(ISSUER_DB_FILE, 'r') as f: self.issuers = json.load(f)
            else: self.issuers = {}
        except Exception as e: messagebox.showerror("DB Error", f"Could not load issuer database: {e}")

    def save_issuers(self):
        try:
            with open(ISSUER_DB_FILE, 'w') as f: json.dump(self.issuers, f, indent=4)
        except Exception as e: messagebox.showerror("DB Error", f"Could not save issuer database: {e}")

    def create_verifier_tab(self):
        frame = self.verifier_frame
        
        ttk.Button(frame, text="Load QR Image...", command=self.scan_and_process_qr, bootstyle="primary").pack(fill='x', pady=5, ipady=8)

        results_frame = ttk.Labelframe(frame, text="Verification Result", padding=15, bootstyle="info")
        results_frame.pack(fill="both", expand=True, pady=10)

        top_container = ttk.Frame(results_frame); top_container.pack(fill="x", pady=(0, 10))
        logo_status_frame = ttk.Frame(top_container); logo_status_frame.pack(side="left", padx=(0, 20), anchor="nw")
        self.logo_label = ttk.Label(logo_status_frame, image=self.logo_placeholder); self.logo_label.pack()

        message_frame = ttk.Frame(top_container); message_frame.pack(side="left", expand=True, fill="x", anchor="nw")
        self.issuer_label = ttk.Label(message_frame, text="Issuer: N/A", font=("Segoe UI", 11, "bold")); self.issuer_label.pack(anchor="w")
        self.message_for_label = ttk.Label(message_frame, text=""); self.message_for_label.pack(anchor="w", pady=(5,0))
        
        style = ttk.Style()
        theme_bg_color = style.colors.get("bg")
        theme_fg_color = style.colors.get("fg")
        self.decoded_message_text = tk.Text(
            message_frame, height=4, wrap="word", font=("Segoe UI", 10, "bold"),
            bd=0, relief='flat', background=theme_bg_color, foreground=theme_fg_color
        )
        self.decoded_message_text.pack(fill="x", expand=True, pady=(2,0))
        self.decoded_message_text.tag_configure("green", foreground=style.colors.get("success"))

        self.doc_image_label = ttk.Label(results_frame, image=self.doc_image_placeholder); self.doc_image_label.pack(fill="both", expand=True, pady=5)
        
        log_frame = ttk.Labelframe(results_frame, text="Verification Log", padding=5, bootstyle="secondary")
        log_frame.pack(fill='x', side='bottom', pady=(10,0))
        
        log_bg_color = style.colors.get('light')
        self.log_text = tk.Text(
            log_frame, height=6, wrap="word", font=('Consolas', 9),
            bd=0, relief='flat', background=log_bg_color
        )
        self.log_text.pack(fill='x', expand=True)
        self.log_text.tag_configure("success", foreground=style.colors.get("success"))
        self.log_text.tag_configure("failure", foreground=style.colors.get("danger"))
        self.log_text.tag_configure("info", foreground=style.colors.get("secondary"))
        self.log_text.tag_configure("warning", foreground=style.colors.get("warning"))

        self.reset_decoder_view()

    def reset_decoder_view(self):
        self.issuer_label.config(text="Issuer: N/A")
        self.logo_label.config(image=self.logo_placeholder); self.logo_label.image = self.logo_placeholder
        self.message_for_label.config(text="")
        self.decoded_message_text.config(state="normal"); self.decoded_message_text.delete("1.0", "end"); self.decoded_message_text.config(state="disabled")
        self.doc_image_placeholder = self.create_text_image((750, 750), "Load a QR code image to begin verification...")
        self.doc_image_label.config(image=self.doc_image_placeholder); self.doc_image_label.image = self.doc_image_placeholder
        if hasattr(self, 'log_text'):
            self.log_text.config(state="normal"); self.log_text.delete("1.0", "end"); self.log_text.config(state="disabled")
    
    def log_message(self, message, style="info"):
        self.root.after(0, self._log_message_thread_safe, message, style)

    def _log_message_thread_safe(self, message, style):
        self.log_text.config(state="normal")
        self.log_text.insert("end", f"> {message}\n", style)
        self.log_text.see("end")
        self.log_text.config(state="disabled")

    def scan_and_process_qr(self):
        self.reset_decoder_view()
        path = filedialog.askopenfilename(filetypes=[("Image Files", "*.png *.jpg")]);
        if not path: return
        
        self.log_message(f"Scanning image: {os.path.basename(path)}...")
        try:
            decoded_qrs = pyzbar.decode(Image.open(path))
        except Exception as e:
            self.log_message(f"Could not open or read image file: {e}", "failure")
            messagebox.showerror("Image Error", f"Could not process the image file.\n\nError: {e}")
            return

        if not decoded_qrs:
            self.log_message("No QR code found in image.", "failure")
            messagebox.showwarning("Not Found", "No QR code could be found in the image.")
            return

        self.log_message(f"Found {len(decoded_qrs)} QR code(s). Analyzing content...")
        qr_data = decoded_qrs[0].data

        try:
            payload = json.loads(qr_data.decode('utf-8'))
            if payload.get("qr_type") == "issuer_info_v1":
                self.log_message("QR identified as an Issuer Info QR. Processing...")
                threading.Thread(target=self.process_issuer_qr, args=(payload,), daemon=True).start()
                return
        except (json.JSONDecodeError, UnicodeDecodeError):
            pass

        self.log_message("QR identified as a Document QR. Starting verification...")
        threading.Thread(target=self.process_verification_qr, args=(qr_data,), daemon=True).start()

    def process_verification_qr(self, qr_data_bytes):
        try:
            issuer_id, payload_b64, signature_b64 = qr_data_bytes.decode('utf-8').split('-', 2)
            self.log_message(f"Parsed document QR for Issuer ID: {issuer_id}")

            if issuer_id not in self.issuers:
                self.log_message(f"Issuer '{issuer_id}' is not in the trusted database.", "failure")
                raise ValueError(f"UNKNOWN ISSUER: '{issuer_id}'")
            issuer_info = self.issuers[issuer_id]
            self.log_message("Issuer found in trusted database.", "success")
            self.root.after(0, lambda: self.issuer_label.config(text=f"Issued by: {issuer_info.get('name', 'N/A')}"))
            self.display_issuer_logo(issuer_id)

            payload_json = self.verify_signature(issuer_info, payload_b64, signature_b64)
            self.log_message("Cryptographic signature is valid.", "success")
            payload = json.loads(payload_json)
            
            self.root.after(0, self.render_formatted_text, payload.get('msg', ''))
            self.fetch_and_verify_doc_image(issuer_info, payload)

        except Exception as e:
            self.log_message(f"Verification failed: {e}", "failure")

    def verify_signature(self, issuer_info, payload_b64, signature_b64):
        pub_key = serialization.load_pem_public_key(issuer_info['pub_key_pem'].encode('utf-8'))
        payload_json = base64.b64decode(payload_b64); signature = base64.b64decode(signature_b64)
        hasher = hashes.Hash(hashes.SHA256()); hasher.update(payload_json); digest = hasher.finalize()
        pub_key.verify(signature, digest, padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH), utils.Prehashed(hashes.SHA256()))
        return payload_json

    def fetch_and_verify_doc_image(self, issuer_info, payload):
        self.log_message("Fetching control image from issuer's server...")
        base_url = issuer_info.get("image_base_url"); img_id = payload.get("imgId")
        if not base_url or not img_id:
            self.log_message("Image URL or ID missing in QR payload.", "failure")
            self.root.after(0, self.display_error_on_image_area, "Signature is valid, but image URL is missing.")
            return

        full_image_url = os.path.join(base_url, img_id).replace("\\", "/")
        try:
            response = requests.get(full_image_url, timeout=10); response.raise_for_status()
            image_data = response.content
            self.log_message("Control image successfully downloaded.", "success")

            self.log_message("Verifying image integrity with checksum...")
            expected_hash = payload.get('h')
            if not expected_hash:
                self.log_message("No hash found in QR. Skipping integrity check.", "warning")
            else:
                image_hash = hashlib.sha256(image_data).hexdigest()[:32]
                if image_hash == expected_hash:
                    self.log_message("Image integrity confirmed. Checksum matches.", "success")
                else:
                    self.log_message("Image integrity check FAILED! The image on the server may have been altered.", "failure")
                    raise ValueError("Image on server does not match original signature.")
            
            pil_img = Image.open(io.BytesIO(image_data)); w, h = pil_img.size
            max_w, max_h = 750, 750
            ratio = min(max_w/w, max_h/h); new_size = (int(w*ratio), int(h*ratio))
            pil_img = pil_img.resize(new_size, Image.Resampling.LANCZOS)
            img_tk = ImageTk.PhotoImage(pil_img)
            self.root.after(0, lambda: [
                self.doc_image_label.config(image=img_tk),
                setattr(self.doc_image_label, 'image', img_tk)
            ])
        except Exception as e:
            self.log_message(f"Failed to load or verify image: {e}", "failure")
            self.root.after(0, self.display_error_on_image_area, f"! Warning: This is a valid certificate, but the control image could not be loaded or verified. Error: {e}")

    def display_error_on_image_area(self, message):
        error_img_tk = self.create_text_image((750, 750), message, color="#FFF3CD", text_color="#D9534F")
        self.doc_image_label.config(image=error_img_tk); self.doc_image_label.image = error_img_tk

    def display_issuer_logo(self, issuer_id):
        threading.Thread(target=self._fetch_logo, args=(issuer_id,), daemon=True).start()

    def _fetch_logo(self, issuer_id):
        logo_url = self.issuers.get(issuer_id, {}).get('logo_url')
        if not logo_url: return
        try:
            response = requests.get(logo_url, timeout=5); response.raise_for_status()
            pil_img = Image.open(io.BytesIO(response.content)).resize((80, 80), Image.Resampling.LANCZOS)
            img_tk = ImageTk.PhotoImage(pil_img)
            self.root.after(0, lambda: [self.logo_label.config(image=img_tk), setattr(self.logo_label, 'image', img_tk)])
        except Exception as e: print(f"Failed to load logo from {logo_url}: {e}")

    def render_formatted_text(self, message):
        self.message_for_label.config(text="This is a certificate for:")
        self.decoded_message_text.config(state="normal")
        self.decoded_message_text.delete("1.0", "end")
        parts = re.split(r'(\[.*?\])', message)
        for part in parts:
            if part.startswith('[') and part.endswith(']'):
                self.decoded_message_text.insert("end", part[1:-1], "green")
            else:
                self.decoded_message_text.insert("end", part)
        self.decoded_message_text.config(state="disabled")

    def create_issuer_tab(self):
        frame = self.issuer_frame; cols = ('ID', 'Name', 'Info URL')
        self.issuer_tree = ttk.Treeview(frame, columns=cols, show='headings', bootstyle="primary")
        self.issuer_tree.pack(fill="both", expand=True)
        for col in cols: self.issuer_tree.heading(col, text=col)
        self.issuer_tree.column("ID", width=120, stretch=False)
        self.issuer_tree.column("Name", width=200)
        
        btn_frame = ttk.Frame(frame); btn_frame.pack(fill='x', pady=(10, 0))
        ttk.Button(btn_frame, text="Forget Selected Issuer", command=self.delete_selected_issuer, bootstyle="outline-danger").pack(side="left", expand=True, fill='x', padx=2)
        ttk.Button(btn_frame, text="Refresh List", command=self.refresh_issuer_list, bootstyle="outline-secondary").pack(side="left", expand=True, fill='x', padx=2)
        self.refresh_issuer_list()
        
    def refresh_issuer_list(self):
        if hasattr(self, 'issuer_tree'):
            for i in self.issuer_tree.get_children(): self.issuer_tree.delete(i)
            for issuer_id, data in sorted(self.issuers.items()):
                self.issuer_tree.insert('', 'end', values=(issuer_id, data['name'], data.get('infoUrl', 'N/A')))
                
    def process_issuer_qr(self, data):
        try:
            issuer_id, name_in_qr, info_url = data.get('id'), data.get('name'), data.get('infoUrl')
            if not all([issuer_id, name_in_qr, info_url]):
                raise ValueError("Issuer QR is missing required fields (id, name, infoUrl).")

            if issuer_id in self.issuers:
                self.log_message(f"Issuer '{name_in_qr}' is already trusted. No action needed.", "warning")
                messagebox.showwarning("Exists", f"You already trust the issuer with ID: {issuer_id}\nName: {self.issuers[issuer_id]['name']}")
                return
            
            self.log_message(f"Found new issuer '{name_in_qr}'.")
            if not messagebox.askyesno("Confirm Trust", f"Do you want to trust this issuer and fetch their public key from:\n{info_url}?"):
                self.log_message("User declined to trust the new issuer.", "warning")
                return
                
            self.log_message(f"Fetching public key from {info_url}...")
            response = requests.get(info_url, timeout=10); response.raise_for_status()
            info_json = response.json()
            self.log_message("Public key file downloaded successfully.", "success")
            
            pub_key_pem, official_name = info_json.get('publicKeyPem'), info_json.get('issuerName', name_in_qr)
            if not pub_key_pem: raise ValueError("Public key file is missing the 'publicKeyPem' field.")
            
            serialization.load_pem_public_key(pub_key_pem.encode('utf-8'))
            self.log_message("Public key is in a valid format.", "success")
            
            self.issuers[issuer_id] = {
                'name': official_name, 'infoUrl': info_url, 'pub_key_pem': pub_key_pem,
                'logo_url': info_json.get('logoUrl'), 'image_base_url': info_json.get('imageBaseUrl')
            }
            self.save_issuers()
            self.refresh_issuer_list()
            self.log_message(f"Successfully learned and trusted new issuer: {official_name}", "success")
            messagebox.showinfo("Success", f"Successfully learned and trusted issuer: {official_name}")
            
        except Exception as e:
            self.log_message(f"Failed to process Issuer QR: {e}", "failure")
            messagebox.showerror("Error", f"Failed to process Issuer QR: {e}")
            
    def delete_selected_issuer(self):
        selected_item = self.issuer_tree.focus()
        if not selected_item:
            messagebox.showwarning("Selection Required", "Please select an issuer from the list to forget.")
            return
        
        issuer_id, issuer_name = self.issuer_tree.item(selected_item)['values'][:2]
        
        if messagebox.askyesno("Confirm Deletion", f"Are you sure you want to forget and no longer trust issuer '{issuer_name}' ({issuer_id})?"):
            if issuer_id in self.issuers:
                del self.issuers[issuer_id]
                self.save_issuers()
                self.refresh_issuer_list()

if __name__ == "__main__":
    root = ttk.Window(themename="litera")
    app = VerifierApp(root)
    root.mainloop()