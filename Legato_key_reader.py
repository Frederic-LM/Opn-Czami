# Copyright (C) 2025 Fr√©d√©ric Levi Mazloum
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see
# <https://www.gnu.org/licenses/>.

# --- Legato key reader - PROOF OF CONCEPT --- for Op'n Czami V3 !!! non compatible with previous versions !!!
# This application serves as a secure verifier for Legato Key generated by the
# Op'n-Cezami app. Its primary purpose is to confirm the authenticity
# and integrity of a digital document without needing a central authority. It
# achieves this through a decentralized, public-key cryptography workflow.
#
#V3.0.1 bug fixed 
#
import tkinter as tk
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from ttkbootstrap.scrolled import ScrolledText
from tkinter import filedialog, messagebox
import json, base64, io, re, requests, os, threading, textwrap, hashlib, zlib, cbor2, base45
from cryptography.hazmat.primitives import serialization
from cryptography.exceptions import InvalidSignature
from PIL import Image, ImageTk, ImageDraw, ImageFont
from pyzbar import pyzbar

ISSUER_DB_FILE = "legatokeyreader.json"

class VerifierApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Czami - Secure Verifier Tool")
        self.root.geometry("800x1100")

        self.issuers = {}
        self.logo_placeholder = ImageTk.PhotoImage(Image.new("RGB", (80, 80), "#E0E0E0"))
        self.doc_image_placeholder = self.create_text_image((750, 750), "Load a Legato Key to begin verification...")

        self.load_issuers()

        self.notebook = ttk.Notebook(root, bootstyle="primary")
        self.notebook.pack(pady=10, padx=10, expand=True, fill="both")
        
        self.verifier_frame = ttk.Frame(self.notebook, padding=10)
        self.issuer_frame = ttk.Frame(self.notebook, padding=10)
        
        self.notebook.add(self.verifier_frame, text='üîç Verify Document')
        self.notebook.add(self.issuer_frame, text='üìö Known Issuers')
        
        self.create_verifier_tab()
        self.create_issuer_tab()
        
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

    def create_text_image(self, size, text, color="#F0F0F0", text_color="dimgray"):
        img = Image.new("RGB", size, color)
        draw = ImageDraw.Draw(img)
        try:
            font = ImageFont.truetype("seguisb.ttf", 22)
        except IOError:
            font = ImageFont.load_default()
        
        wrapped_text = textwrap.wrap(text, width=55)
        total_text_height = sum([font.getbbox(line)[3] for line in wrapped_text]) + (len(wrapped_text) - 1) * 5
        current_y = (size[1] - total_text_height) / 2
        
        for line in wrapped_text:
            line_bbox = font.getbbox(line)
            line_width = line_bbox[2] - line_bbox[0]
            position = ((size[0] - line_width) / 2, current_y)
            draw.text(position, line, fill=text_color, font=font)
            current_y += font.getbbox(line)[3] + 5

        return ImageTk.PhotoImage(img)

    def on_closing(self):
        self.save_issuers()
        self.root.destroy()
    
    def load_issuers(self):
        try:
            if os.path.exists(ISSUER_DB_FILE):
                with open(ISSUER_DB_FILE, 'r') as f:
                    self.issuers = json.load(f)
            else:
                self.issuers = {}
        except Exception as e:
            messagebox.showerror("DB Error", f"Could not load issuer database: {e}")

    def save_issuers(self):
        try:
            with open(ISSUER_DB_FILE, 'w') as f:
                json.dump(self.issuers, f, indent=4)
        except Exception as e:
            messagebox.showerror("DB Error", f"Could not save issuer database: {e}")

    def create_verifier_tab(self):
        frame = self.verifier_frame
        
        ttk.Button(frame, text="Load QR Image...", command=self.scan_and_process_qr, bootstyle="primary").pack(fill='x', pady=5, ipady=8)

        results_frame = ttk.Labelframe(frame, text="Verification Result", padding=15, bootstyle="info")
        results_frame.pack(fill="both", expand=True, pady=10)

        top_container = ttk.Frame(results_frame)
        top_container.pack(fill="x", pady=(0, 10))
        logo_status_frame = ttk.Frame(top_container)
        logo_status_frame.pack(side="left", padx=(0, 20), anchor="nw")
        self.logo_label = ttk.Label(logo_status_frame, image=self.logo_placeholder)
        self.logo_label.pack()

        message_frame = ttk.Frame(top_container)
        message_frame.pack(side="left", expand=True, fill="x", anchor="nw")
        self.issuer_label = ttk.Label(message_frame, text="Issuer: N/A", font=("Segoe UI", 11, "bold"))
        self.issuer_label.pack(anchor="w")
        
        style = ttk.Style()
        theme_bg_color = style.colors.get("bg")
        theme_fg_color = style.colors.get("fg")
        self.decoded_message_text = tk.Text(
            message_frame, height=5, wrap="word", font=("Segoe UI", 10),
            bd=0, relief='flat', background=theme_bg_color, foreground=theme_fg_color, state="disabled"
        )
        self.decoded_message_text.pack(fill="x", expand=True, pady=(2,0))
        self.decoded_message_text.tag_configure("bold", font=("Segoe UI", 10, "bold"))
        self.decoded_message_text.tag_configure("green", foreground=style.colors.get("success"), font=("Segoe UI", 10, "bold"))

        self.doc_image_label = ttk.Label(results_frame, image=self.doc_image_placeholder)
        self.doc_image_label.pack(fill="both", expand=True, pady=5)
        
        log_frame = ttk.Labelframe(results_frame, text="Verification Log", padding=5, bootstyle="secondary")
        log_frame.pack(fill='x', side='bottom', pady=(10,0))
        
        log_bg_color = style.colors.get('light')
        self.log_text = ScrolledText(
            log_frame, height=8, wrap="word", font=('Consolas', 9), autohide=True,
            bd=0, relief='flat', bg=log_bg_color
        )
        self.log_text.pack(fill='x', expand=True)
        self.log_text.text.config(state="disabled")
        self.log_text.tag_configure("success", foreground=style.colors.get("success"))
        self.log_text.tag_configure("failure", foreground=style.colors.get("danger"))
        self.log_text.tag_configure("info", foreground=style.colors.get("secondary"))
        self.log_text.tag_configure("warning", foreground=style.colors.get("warning"))

        self.reset_decoder_view()

    def create_issuer_tab(self):
        frame = self.issuer_frame
        cols = ('ID', 'Name', 'Info URL')
        self.issuer_tree = ttk.Treeview(frame, columns=cols, show='headings', bootstyle="primary")
        self.issuer_tree.pack(fill="both", expand=True)
        for col in cols:
            self.issuer_tree.heading(col, text=col)
        self.issuer_tree.column("ID", width=200, stretch=False)
        self.issuer_tree.column("Name", width=250)
        
        btn_frame = ttk.Frame(frame)
        btn_frame.pack(fill='x', pady=(10, 0))
        ttk.Button(btn_frame, text="Forget Selected Issuer", command=self.delete_selected_issuer, bootstyle="outline-danger").pack(side="left", expand=True, fill='x', padx=2)
        ttk.Button(btn_frame, text="Refresh List", command=self.refresh_issuer_list, bootstyle="outline-secondary").pack(side="left", expand=True, fill='x', padx=2)
        self.refresh_issuer_list()

    def reset_decoder_view(self):
        self.issuer_label.config(text="Issuer: N/A")
        self.logo_label.config(image=self.logo_placeholder)
        self.logo_label.image = self.logo_placeholder
        self.decoded_message_text.config(state="normal")
        self.decoded_message_text.delete("1.0", "end")
        self.decoded_message_text.config(state="disabled")
        self.doc_image_placeholder = self.create_text_image((750, 750), "Load a QR code image to begin verification...")
        self.doc_image_label.config(image=self.doc_image_placeholder)
        self.doc_image_label.image = self.doc_image_placeholder
        if hasattr(self, 'log_text'):
            self.log_text.text.config(state="normal")
            self.log_text.text.delete("1.0", "end")
            self.log_text.text.config(state="disabled")
    
    def log_message(self, message, style="info"):
        self.root.after(0, self._log_message_thread_safe, message, style)

    def _log_message_thread_safe(self, message, style):
        self.log_text.text.config(state="normal")
        self.log_text.text.insert("end", f"> {message}\n", style)
        self.log_text.text.see("end")
        self.log_text.text.config(state="disabled")

    def scan_and_process_qr(self):
        self.reset_decoder_view()

        path = filedialog.askopenfilename(filetypes=[("Image Files", "*.png *.jpg")])
        if not path: return
        
        self.log_message(f"Scanning image: {os.path.basename(path)}...")
        try:
            decoded_qrs = pyzbar.decode(Image.open(path))
        except Exception as e:
            self.log_message(f"ERROR: Could not open image: {e}", "failure")
            messagebox.showerror("Image Error", f"Could not process the image file.\n\nError: {e}")
            return

        if not decoded_qrs:
            self.log_message("FAILURE: No QR code found.", "failure")
            messagebox.showwarning("Not Found", "No QR code could be found in the image.")
            return

        self.log_message(f"SUCCESS: Found {len(decoded_qrs)} QR code(s).", "success")
        
        raw_bytes = decoded_qrs[0].data
        
        try:
            qr_string = raw_bytes.decode('utf-8')
        except UnicodeDecodeError:
            self.log_message("ERROR: QR data is not valid UTF-8.", "failure")
            return
        
        if qr_string.strip().startswith('{') or qr_string.strip().startswith('i') or qr_string.strip().startswith('n'):
            self.log_message("Detected Issuer QR format...", "info")
            threading.Thread(target=self.process_issuer_data_flow, args=(qr_string,), daemon=True).start()

        elif ':' in qr_string:
            self.log_message("Detected Document QR format. Starting verification...", "info")
            threading.Thread(target=self.process_verification_qr, args=(qr_string,), daemon=True).start()

        else:
            self.log_message("ERROR: Unrecognized QR code format.", "failure")

    def process_verification_qr(self, qr_string):
        try:
            # 1. Parse and normalize the Issuer ID (Critical Fix)
            issuer_id, payload_b45 = qr_string.split(':', 1)
            issuer_id = issuer_id.strip().lower()

            # 2. Check for trust
            issuer_info = self.issuers.get(issuer_id)
            if not issuer_info:
                raise ValueError(f"Issuer '{issuer_id}' is not in the trusted database. Please add them first.")
            self.log_message(f"Issuer '{issuer_info['name']}' found in trusted database.", "success")
            self.root.after(0, lambda: self.issuer_label.config(text=f"Issued by: {issuer_info.get('name', 'N/A')}"))
            self.display_issuer_logo(issuer_id)

            # 3. Decode payload
            combined_bytes = base45.b45decode(payload_b45)
            
            # 4. Split signature from the compressed data
            signature_bytes = combined_bytes[-64:]
            payload_compressed = combined_bytes[:-64]
            
            # 5. Cryptographic Verification (Final Fix: Ed25519 direct verify)
            pub_key = serialization.load_pem_public_key(issuer_info['pub_key_pem'].encode('utf-8'))
            pub_key.verify(signature_bytes, payload_compressed) # Correct Ed25519 verification
            
            self.log_message("SUCCESS: Cryptographic signature is valid.", "success")

            # 6. Decompress and decode the payload
            payload_cbor = zlib.decompress(payload_compressed, wbits=-15)
            decoded_payload = cbor2.loads(payload_cbor)

            # 7. Extract data
            public_message = decoded_payload.get('m', 'No message provided.')
            doc_num = decoded_payload.get('n')
            self.root.after(0, self.render_formatted_text, public_message, doc_num)

            filename_stem = decoded_payload.get('i')
            expected_hash = decoded_payload.get('h', b'').hex()
            if not filename_stem or not expected_hash:
                raise ValueError("Payload is missing image filename or hash.")
            self.log_message("Payload decoded. Now verifying control file integrity...")
            
            payload_for_fetch = {'imgId': f"{filename_stem}.lky", 'h': expected_hash}
            self.fetch_and_verify_doc_image(issuer_info, payload_for_fetch)

        except InvalidSignature:
            self.log_message("VERIFICATION FAILED: Invalid cryptographic signature.", "failure")
            self.root.after(0, self.display_error_on_image_area, "VERIFICATION FAILED!\n\nInvalid Signature: This is NOT an authentic Legato Key.")
        except ValueError as e:
            self.log_message(f"VERIFICATION FAILED: {e}", "failure")
            self.root.after(0, self.display_error_on_image_area, f"VERIFICATION FAILED!\n\nError: {e}")
        except Exception as e:
            self.log_message(f"VERIFICATION FAILED: An unexpected error occurred: {e}", "failure")
            self.root.after(0, self.display_error_on_image_area, f"VERIFICATION FAILED!\n\nUnexpected Error: {e}")

    def fetch_and_verify_doc_image(self, issuer_info, payload):
        self.log_message("Fetching control file from issuer's server...")
        base_url = issuer_info.get("image_base_url"); img_id = payload.get("imgId")
        if not base_url or not img_id:
            self.log_message("ERROR: Image URL or ID missing in QR payload.", "failure")
            self.root.after(0, self.display_error_on_image_area, "Signature is valid, but image URL is missing.")
            return

        full_lky_url = os.path.join(base_url, img_id).replace("\\", "/")
        try:
            response = requests.get(full_lky_url, timeout=10); response.raise_for_status()
            lky_file_data = response.content
            self.log_message("SUCCESS: Control LKY file successfully downloaded.", "success")

            self.log_message("Verifying LKY file integrity with checksum...")
            expected_hash = payload.get('h')
            
            # FINAL FIX: Truncate the hash to 32 chars to match the signing app.
            calculated_hash = hashlib.sha256(lky_file_data).hexdigest()[:32]

            if calculated_hash != expected_hash:
                self.log_message("FAILURE: LKY file integrity check FAILED!", "failure")
                self.log_message(f"   - Expected Hash: {expected_hash}", "failure")
                self.log_message(f"   - Calculated Hash: {calculated_hash}", "failure")
                raise ValueError("INTEGRITY CHECK FAILED: The file on the server has been modified.")
            
            self.log_message("SUCCESS: LKY file integrity confirmed. Checksum matches.", "success")
            
            # Extract image
            manifest_len_bytes = lky_file_data[-4:]
            manifest_len = int.from_bytes(manifest_len_bytes, 'big')
            manifest_start = len(lky_file_data) - 4 - manifest_len
            manifest_json_bytes = lky_file_data[manifest_start:-4]
            manifest = json.loads(manifest_json_bytes)
            image_length = manifest.get('imageLength')

            if not image_length:
                raise ValueError("LKY manifest is corrupt or missing 'imageLength'.")

            image_data = lky_file_data[:image_length]

            pil_img = Image.open(io.BytesIO(image_data)); w, h = pil_img.size
            max_w, max_h = 750, 750
            ratio = min(max_w/w, max_h/h); new_size = (int(w*ratio), int(h*ratio))
            pil_img = pil_img.resize(new_size, Image.Resampling.LANCZOS)
            img_tk = ImageTk.PhotoImage(pil_img)
            self.root.after(0, lambda: [
                self.doc_image_label.config(image=img_tk),
                setattr(self.doc_image_label, 'image', img_tk)
            ])
            self.log_message("SUCCESS: Authenticated image displayed.", "success")
        except Exception as e:
            self.log_message(f"ERROR: Failed during file download or LKY extraction: {e}", "failure")
            self.root.after(0, self.display_error_on_image_area, f"! Warning: Valid certificate, but control file failed integrity or download check. Error: {e}")

    def display_error_on_image_area(self, message):
        error_img_tk = self.create_text_image((750, 750), message, color="#FFF3CD", text_color="#D9534F")
        self.doc_image_label.config(image=error_img_tk); self.doc_image_label.image = error_img_tk

    def display_issuer_logo(self, issuer_id):
        threading.Thread(target=self._fetch_logo, args=(issuer_id,), daemon=True).start()

    def _fetch_logo(self, issuer_id):
        logo_url = self.issuers.get(issuer_id, {}).get('logo_url')
        if not logo_url: return
        try:
            response = requests.get(logo_url, timeout=5); response.raise_for_status()
            pil_img = Image.open(io.BytesIO(response.content)).resize((80, 80), Image.Resampling.LANCZOS)
            img_tk = ImageTk.PhotoImage(pil_img)
            self.root.after(0, lambda: [self.logo_label.config(image=img_tk), setattr(self.logo_label, 'image', img_tk)])
        except Exception as e: print(f"Failed to load logo from {logo_url}: {e}")

    def render_formatted_text(self, message, doc_num=None):
        self.decoded_message_text.config(state="normal")
        self.decoded_message_text.delete("1.0", "end")
        
        # Display document number if available
        if doc_num:
            self.decoded_message_text.insert("end", "Document #: ", "bold")
            self.decoded_message_text.insert("end", f"{doc_num}\n\n", "green")
        
        # Display the signed message
        self.decoded_message_text.insert("end", message)
        self.decoded_message_text.config(state="disabled")

    def refresh_issuer_list(self):
        if hasattr(self, 'issuer_tree'):
            for i in self.issuer_tree.get_children(): self.issuer_tree.delete(i)
            for issuer_id, data in sorted(self.issuers.items()):
                self.issuer_tree.insert('', 'end', values=(issuer_id, data['name'], data.get('infoUrl', 'N/A')))

    def process_issuer_data_flow(self, qr_string):
        """Dispatches to the correct issuer data processor (JSON vs. Compressed)."""
        data = None
        try:
            if qr_string.strip().startswith('{'):
                # Legacy JSON Issuer
                data = json.loads(qr_string)
            elif ':' not in qr_string:
                # New Compressed Issuer (No colon separator, full string is B45 payload)
                compressed_data = base45.b45decode(qr_string)
                json_string = zlib.decompress(compressed_data).decode('utf-8')
                data = json.loads(json_string)
            else:
                # Fallback for unexpected format
                raise ValueError("QR string does not match any known issuer format.")

            if data:
                self._add_issuer_from_payload(data)

        except Exception as e:
            self.log_message(f"ERROR: Failed to decode/process Issuer QR payload: {e}", "failure")
            messagebox.showerror("Error", f"Failed to process Issuer QR: {e}")

    def _add_issuer_from_payload(self, data):
        """Fetches public key and adds new issuer to the trusted database."""
        try:
            issuer_id = data.get('id', data.get('issuer_id', 'N/A')).strip().lower()
            name_in_qr = data.get('name', data.get('issuerName', 'N/A'))
            info_url = data.get('infoUrl')

            if not all([issuer_id, name_in_qr, info_url]):
                raise ValueError("Issuer QR data is missing required fields.")

            if issuer_id in self.issuers:
                self.log_message(f"Issuer '{name_in_qr}' is already trusted.", "warning")
                messagebox.showwarning("Exists", f"You already trust issuer: {self.issuers[issuer_id]['name']}")
                return
            
            self.log_message(f"Found new issuer '{name_in_qr}'.")
            if not messagebox.askyesno("Confirm Trust", f"Do you want to trust this issuer and fetch their public key from:\n{info_url}?"):
                self.log_message("User declined to trust.", "warning")
                return
                
            self.log_message(f"Fetching public key from {info_url}...")
            response = requests.get(info_url, timeout=10); response.raise_for_status()
            info_json = response.json()
            self.log_message("Public key file downloaded.", "success")
            
            pub_key_pem = info_json.get('publicKeyPem')
            official_name = info_json.get('issuerName', name_in_qr)
            if not pub_key_pem: raise ValueError("Public key file is missing 'publicKeyPem' field.")
            
            self.log_message("Validating public key format...")
            serialization.load_pem_public_key(pub_key_pem.encode('utf-8')) # Validates PEM format
            self.log_message("SUCCESS: Public key is valid.", "success")
            
            self.issuers[issuer_id] = {
                'name': official_name, 'infoUrl': info_url, 'pub_key_pem': pub_key_pem,
                'logo_url': info_json.get('logoUrl'), 'image_base_url': info_json.get('imageBaseUrl')
            }
            self.save_issuers()
            self.refresh_issuer_list()
            self.log_message(f"Successfully trusted new issuer: {official_name}", "success")
            messagebox.showinfo("Success", f"Successfully learned and trusted issuer: {official_name}")
            
        except Exception as e:
            self.log_message(f"ERROR: Failed to add issuer: {e}", "failure")
            messagebox.showerror("Error", f"Failed to add issuer: {e}")

    def delete_selected_issuer(self):
        selected_item = self.issuer_tree.focus()
        if not selected_item:
            messagebox.showwarning("Selection Required", "Please select an issuer to forget.")
            return
        
        issuer_id, issuer_name = self.issuer_tree.item(selected_item)['values'][:2]
        
        if messagebox.askyesno("Confirm Deletion", f"Are you sure you want to forget and no longer trust '{issuer_name}'?"):
            if issuer_id in self.issuers:
                del self.issuers[issuer_id]
                self.save_issuers()
                self.refresh_issuer_list()

if __name__ == "__main__":
    root = ttk.Window(themename="litera")
    app = VerifierApp(root)
    root.mainloop()
